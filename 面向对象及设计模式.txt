名词解释：
	
	耦合：
		也称块间联系。指软件系统结构中各模块间相互联系紧密程度的一种度量。模块
		之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决
		于模块间接口的复杂性、调用的方式及传递的信息。属于一种特殊的关联关系，
		比如一个类A作为另一个类B的属性，并且类A的引用不单单只有类b持有，比如类A
		是外部创建好传入类B的，当B结束生命周期时，A可能还存在。
		
	组合：
		属于一种特殊的聚合，就是当B结束生命周期时，A也结束了，不会再存在，一般
		是只有类B才支持其实例。
		
	
	内聚：
		又称块内联系。指模块的功能强度的度量，即一个模块内部各个元素彼此结合的
		紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，
		则它的内聚性就越高

面向对象：

	六大原则：
		
		1.单一职责原则 Single Responsibility Principle (SRP)
			一个类中应该是一组相关性很高的函数和数据的封装。核心（解耦和增内聚）
			但是所谓的职责是不好划分的，个人认为，一个类最好只做一件事，这样就
			可以避免做多件事的时候，事1的改变导致事2的不能正常运行。
			
		2.开闭原则 Open Close Principle (OCP)
			软件中的对象（类、模块、函数等）应该对于扩展时开放的，对于修改是封闭的
			但现实一般都是在扩展代码的同时会修改原有代码。而遵守开闭原则的最好手段
			就是通过抽象（抽象类或接口）来完成。
			
		3.里氏替换原则 Liskov Substitution Principle (LSP)
			直接搬定义，所有引用基类的地方必须能透明的使用其子类的对象。这个原则
			就是依赖于继承、多态这两大特性。（引用子类的地方，父类不一定可行）
			
		4.依赖倒置原则 Dependence Inversion Principle (DIP)
			解耦，使高层次的模块不依赖于低层次的模块的实现细节，即各自依赖其抽象。
			细节依赖抽象，反之不行。
			
		5.接口隔离原则 InterfaceSegregation Principle (ISP)
			类之间的依赖关系应该建立在最小的接口上。  以上是五大原则SOLID
			
		6.迪米特原则 Law of Demeter (LOD)	
			一个对象应该对其他对象有最少的了解。
			
	以上六大原则看似定义不同，但具体的实现都离不开三大特性，即封装、继承、多态，其实
	也是这三大特性的合理使用，不断的打代码，不断的思考，会发现这些原则会让你在开发
	之路上神清气爽。
			
	三大特性：
		
		1.封装
			其实单一职责就是一个很好的解释，也是在进行类的封装的时候的最好指导。
			
		2.继承
			可以使用现有类的所有功能，并在无需重新编写。官方说子类不继承父类的私有
			成员属性，但是子类可以通过继承的（public or protected）的方法来使用。例
			如属性的get方法。
			
		3.多态
			动态绑定，父类会根据被实例的子类的不同，而动态的去调用子类的方法。
			
设计模式：
	
	1.单例模式
		某个类只有一个实例，存在的原因是这个类的实例化会消耗很多的资源。
		实现时最重要的一点是构造方法要私有化，通过静态方法或枚举返回单例对象。
		其他的几个点就是保证多线程下的单例，单例对象在反序列话时不会新建对象。
		
		饿汉模式：
			声明时即初始化。
		懒汉模式：
			调用返回实例的方法中初始化。	
		Double Check Lock(DCL) ：
			通过synchronized锁定class，已保证线程安全。同时前后两次判断单例是否null
			但是有失效的情况，new A()操作不是原子操作，会被编译成多条汇编，大致做
			三件事，实例分配内存、调用构造方法初始化成员在、实例指向内存，在java1.5
			前，第二三步可能会顺序颠倒，从而导致这种极限失效问题的存在，使用volatile
			声明单例可保正确性。java6以后正常。
		静态内部类单例模式
			public class A{
				private A();
				public static A getInstance(){
					return InnerA.instance;
				}
				private static class InnerA{
					private static final A instance = new A();
				}
			}
		以上方式在类中需加入这段代码，才能保证反序列化时不会产生新对象：
			private Object readResolve() throw objectStreamException{
				return '单例对象'
			}
		枚举单例
			public enum A{
				INSTANCE;
				....
			}
		
	2.Builder模式
		
	3.原型模式
	4.工厂模式
	5.抽象工厂模式
	6.策略模式
	7.状态模式
	8.责任链模式
	9.解释器模式
	10.命令模式
	11.观察者模式
	12.备忘录模式
	13.迭代器模式
	14.模板模式
	15.访问者模式
	16.中介者模式
	17.代理模式
	18.组合模式
	19.适配器模式
	20.装饰模式
	21.享元模式
	22.外观模式
	23.桥接模式
	
			
			
			
			
			
			